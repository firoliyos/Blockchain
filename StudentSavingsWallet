// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title StudentSavingsWallet
 * @dev A decentralized savings wallet that allows users to deposit, store, and withdraw ETH
 */
contract StudentSavingsWallet {
    // Mapping to store user balances
    mapping(address => uint256) public balances;
    
    // Struct to represent a transaction
    struct Transaction {
        address user;
        uint256 amount;
        uint256 timestamp;
        string transactionType; // "deposit" or "withdraw"
    }
    
    // Array to store all transactions
    Transaction[] public transactionHistory;
    
    // Mapping to store user-specific transaction indices
    mapping(address => uint256[]) public userTransactionIndices;
    
    // Events for better transparency and frontend integration
    event Deposit(address indexed user, uint256 amount, uint256 timestamp);
    event Withdrawal(address indexed user, uint256 amount, uint256 timestamp);
    
    /**
     * @dev Allows users to deposit ETH into their wallet
     * @notice This is a payable function that accepts ETH deposits
     */
    function deposit() public payable {
        require(msg.value > 0, "Deposit amount must be greater than 0");
        
        // Update user balance
        balances[msg.sender] += msg.value;
        
        // Record transaction
        Transaction memory newTransaction = Transaction({
            user: msg.sender,
            amount: msg.value,
            timestamp: block.timestamp,
            transactionType: "deposit"
        });
        
        transactionHistory.push(newTransaction);
        userTransactionIndices[msg.sender].push(transactionHistory.length - 1);
        
        // Emit event
        emit Deposit(msg.sender, msg.value, block.timestamp);
    }
    
    /**
     * @dev Allows users to withdraw ETH from their wallet
     * @param amount The amount of ETH to withdraw (in wei)
     * @notice Users can only withdraw if they have sufficient balance
     */
    function withdraw(uint256 amount) public {
        require(amount > 0, "Withdrawal amount must be greater than 0");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // Update user balance
        balances[msg.sender] -= amount;
        
        // Record transaction
        Transaction memory newTransaction = Transaction({
            user: msg.sender,
            amount: amount,
            timestamp: block.timestamp,
            transactionType: "withdraw"
        });
        
        transactionHistory.push(newTransaction);
        userTransactionIndices[msg.sender].push(transactionHistory.length - 1);
        
        // Transfer ETH to user
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Transfer failed");
        
        // Emit event
        emit Withdrawal(msg.sender, amount, block.timestamp);
    }
    
    /**
     * @dev View function to check user's balance
     * @param user The address of the user
     * @return The balance of the user in wei
     */
    function getBalance(address user) public view returns (uint256) {
        return balances[user];
    }
    
    /**
     * @dev View function to get the caller's own balance
     * @return The balance of the caller in wei
     */
    function myBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
    
    /**
     * @dev View function to get total number of transactions
     * @return The total number of transactions recorded
     */
    function getTransactionCount() public view returns (uint256) {
        return transactionHistory.length;
    }
    
    /**
     * @dev View function to get a specific transaction by index
     * @param index The index of the transaction in the history array
     * @return user The address that made the transaction
     * @return amount The amount involved in the transaction
     * @return timestamp When the transaction occurred
     * @return transactionType Whether it was a "deposit" or "withdraw"
     */
    function getTransaction(uint256 index) public view returns (
        address user,
        uint256 amount,
        uint256 timestamp,
        string memory transactionType
    ) {
        require(index < transactionHistory.length, "Transaction index out of bounds");
        Transaction memory transaction = transactionHistory[index];
        return (
            transaction.user,
            transaction.amount,
            transaction.timestamp,
            transaction.transactionType
        );
    }
    
    /**
     * @dev View function to get all transactions for a specific user
     * @param user The address of the user
     * @return An array of transaction indices belonging to the user
     */
    function getUserTransactionIndices(address user) public view returns (uint256[] memory) {
        return userTransactionIndices[user];
    }
    
    /**
     * @dev View function to get user's transaction count
     * @param user The address of the user
     * @return The number of transactions made by the user
     */
    function getUserTransactionCount(address user) public view returns (uint256) {
        return userTransactionIndices[user].length;
    }
    
    /**
     * @dev View function to get all transactions (for transparency)
     * @return An array of all transactions
     * @notice This function may consume a lot of gas for large arrays
     */
    function getAllTransactions() public view returns (Transaction[] memory) {
        return transactionHistory;
    }
    
    /**
     * @dev View function to get contract's total ETH balance
     * @return The total ETH stored in the contract
     */
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
